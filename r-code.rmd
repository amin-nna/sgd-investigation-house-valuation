# Load libraries
library(tidyverse)
library(GGally)
library(corrplot)

# Load the dataset
df_raw <- read.csv("house-prices.csv", stringsAsFactors = FALSE)

# EDA on Key Numeric Variables
key_numeric_vars <- c("SalePrice", "OverallQual", "GrLivArea", 
                      "TotalBsmtSF", "YearBuilt", "GarageCars", "LotArea")
df_numeric <- df_raw %>% select(any_of(key_numeric_vars))
df_numeric %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  ggplot(aes(x = Value)) +
  facet_wrap(~ Variable, scales = "free", ncol = 3) +
  geom_histogram(bins = 30, fill = "steelblue", color = "white") +
  labs(title = "Histograms of Key Numeric Variables", x = NULL, y = "Count") +
  theme_minimal()

# Boxplots of key numeric variables
df_numeric %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Value") %>%
  ggplot(aes(x = Variable, y = Value)) +
  geom_boxplot(fill = "lightblue", color = "darkblue") +
  coord_flip() +
  labs(title = "Boxplots of Key Numeric Variables", x = "Variable", y = "Value")

# Correlation plot of key numeric variables
corr_matrix_key <- cor(df_numeric, use = "complete.obs")
corrplot(corr_matrix_key, 
         method = "circle",
         type = "upper",
         tl.cex = 0.8,
         title = "Correlation Plot of Key Numeric Variables", 
         mar = c(0, 0, 1, 0))

# Scatterplot matrix using GGally
ggpairs(df_numeric)

# EDA on Key Categorical Variables
key_cat_vars <- c("Neighborhood", "HouseStyle")
df_cat <- df_raw %>% select(any_of(key_cat_vars))

# Bar plots for each categorical variable
for (var in names(df_cat)) {
  p <- ggplot(df_cat, aes(x = !!sym(var))) +
    geom_bar(fill = "skyblue", color = "black") +
    labs(title = paste("Frequency of", var), x = var, y = "Count") +
    theme(axis.text.x = element_text(angle = 45, hjust = 1))
  print(p)
}

set.seed(123)
#Load and preprocess data
df_raw <- read.csv("house-prices.csv", stringsAsFactors = FALSE)

# Impute missing numeric values with the median
numeric_cols <- names(df_raw)[sapply(df_raw, is.numeric)]
for (col in numeric_cols) {
  df_raw[[col]][is.na(df_raw[[col]])] <- median(df_raw[[col]], na.rm = TRUE)
}

# Impute missing categorical values with "None"
categorical_cols <- names(df_raw)[sapply(df_raw, is.character)]
for (col in categorical_cols) {
  df_raw[[col]][is.na(df_raw[[col]])] <- "None"
}

# Convert character columns to factors
df_raw <- df_raw %>% mutate_if(is.character, as.factor)

# Refresh factor levels
df_clean <- df_raw %>% mutate_if(is.factor, droplevels)

# Identify and remove factor columns with fewer than 2 levels
bad_factors <- sapply(df_clean, function(x) is.factor(x) && length(levels(x)) < 2)
if (any(bad_factors)) {
  cat("Removing constant factor variables:\n")
  print(names(bad_factors)[bad_factors])
  df_clean <- df_clean %>% select(-one_of(names(bad_factors)[bad_factors]))
}

# Build full design matrix (no sub setting) and center the log response
X_house <- scale( model.matrix(SalePrice ~ . - 1, data = df_clean) )
y_house <- log(df_clean$SalePrice) - mean(log(df_clean$SalePrice))

# Sanity check dimensions
dim(X_house)    # should be (n_obs) x (n_features)
length(y_house) # should be n_obs

# Compute critical mini-batch size
n <- nrow(X_house)
row_norms_sq <- rowSums(X_house^2)
max_norm_sq <- max(row_norms_sq)
H <- (1/n) * t(X_house) %*% X_house
lambda_max <- max(eigen(H, only.values = TRUE)$values)
m_star <- max_norm_sq / lambda_max
print(paste("Critical mini-batch size m* is approximatively ", round(m_star, 2))

# Function to time SGD
time_sgd <- function(X, y, lr, n_iter, batch_size) {
  start_time <- Sys.time()
  result <- sgd(X, y, lr = lr, n_iter = n_iter, batch_size = batch_size)
  end_time <- Sys.time()
  list(model = result, time = as.numeric(difftime(end_time, start_time, units = "secs")))
}

# Timed SGD runs for various batch sizes
sgd_house_1     <- time_sgd(X_house, y_house, 1e-3, 500, 1)
sgd_house_10    <- time_sgd(X_house, y_house, 1e-3, 500, 10)
sgd_house_20    <- time_sgd(X_house, y_house, 1e-3, 500, 20)
sgd_house_50    <- time_sgd(X_house, y_house, 1e-3, 500, 50)
sgd_house_100   <- time_sgd(X_house, y_house, 1e-3, 500, 100)
sgd_house_200   <- time_sgd(X_house, y_house, 1e-3, 500, 200)
sgd_house_250   <- time_sgd(X_house, y_house, 1e-3, 500, 250)
sgd_house_full  <- time_sgd(X_house, y_house, 1e-3, 500, n)

# Timing comparison table
df_times <- data.frame(
  Method = c("SGD (batch=1)", "SGD (batch=10)", "SGD (batch=20)",
             "SGD (batch=50)", "SGD (batch=100)", "SGD (batch=200)",
             "SGD (batch=250)", "Full Batch"),
  TimeSeconds = c(sgd_house_1$time, sgd_house_10$time, sgd_house_20$time,
                  sgd_house_50$time, sgd_house_100$time, sgd_house_200$time,
                  sgd_house_250$time, sgd_house_full$time)
)
print(df_times)

# Convergence curves
df_convergence_house <- data.frame(
  Iteration = rep(1:500, 8),
  MSE = c(sgd_house_1$model$mse_history, sgd_house_10$model$mse_history,
          sgd_house_20$model$mse_history, sgd_house_50$model$mse_history,
          sgd_house_100$model$mse_history, sgd_house_200$model$mse_history,
          sgd_house_250$model$mse_history, sgd_house_full$model$mse_history),
  Method = rep(df_times$Method, each = 500)
)

ggplot(df_convergence_house, aes(x = Iteration, y = MSE, color = Method)) +
  geom_line() +
  labs(title = "Convergence of Gradient Descent Methods (House Prices Dataset)",
       x = "Iteration", y = "Mean Squared Error") +
  theme_minimal()

# Bar plot of time
df_times$Method <- factor(df_times$Method, levels = df_times$Method)
ggplot(df_times, aes(x = Method, y = TimeSeconds, fill = Method)) +
  geom_bar(stat = "identity") +
  labs(title = "Time Comparison by Mini-Batch Size",
       x = "Method", y = "Time (seconds)") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1), legend.position = "none")

# Count non-zero coefficients
count_nonzero <- function(beta, tol = 1e-5) sum(abs(beta) > tol)
retained_summary <- data.frame(
  Method = df_times$Method,
  NonZeroPredictors = sapply(list(sgd_house_1, sgd_house_10, sgd_house_20,
                                  sgd_house_50, sgd_house_100, sgd_house_200,
                                  sgd_house_250, sgd_house_full),
                             function(obj) count_nonzero(obj$model$beta))
)
print(retained_summary)

# Final MSE per method
final_mse <- function(mse_vec) tail(mse_vec, 1)
df_final_mse <- data.frame(
  Method = df_times$Method,
  FinalMSE = sapply(list(sgd_house_1, sgd_house_10, sgd_house_20,
                         sgd_house_50, sgd_house_100, sgd_house_200,
                         sgd_house_250, sgd_house_full),
                    function(obj) final_mse(obj$model$mse_history))
)
print(df_final_mse)
